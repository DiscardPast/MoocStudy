# 设计模式(Design Pattern)
**是一套被反复使用,多数人知晓的,经过分类编目的,代码设计经验的总结**
**目的:使用设计模式是为了可重用代码,让代码更容易被他人理解,保证代码的可靠性.**

### 设计模式类型
* 创建型模式
	- 工厂方法模式
	- ![TCP/IP模型与OSI模型的对应](https://github.com/DiscardPast/MoocStudy/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE/TCPIP%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94.png)
		- 工厂模式概念:
			- 实例化对象,用工厂方法代替new操作
			- 工厂模式包括工厂方法模式和抽象工厂模式
			- 抽象工厂模式是工厂方法模式的扩展
		- 工厂模式的意图:
			- 定义一个借口来创建对象,但是让子类来决定哪些类需要被实例化
     		- 工厂方法把实例化的工作推迟到子类中去实现
		- 什么情况下适合工厂模式
        	- 有一组类似的对象需要创建
        	- 在编码时不能预见需要创建哪种类的实例
        	- 系统需要考虑扩展性,不应该依赖于产品类实力如何被创建,组合和表达的细节
		- 工厂模式的动机
			- 项目中的现状
				- 在软件系统中经常面临这"对象"的创建工作,鱿鱼须企鹅的变化,这个对象可能随之也会发生变化,但它却拥有比较稳定的接口
				- 为此，我们需要提供一种封装机制莱格里出这个一边对象的变化，从而保持系统中其他依赖该对象的对象不随着需求变化而变化
			- 基于项目现状将代码进行如下设计
				- 尽量松耦合，一个对象的依赖对象的变化与本身无关
				- 具体产品与客户端剥离，责任分割
		- 常见应用
		- ![TCP/IP模型与OSI模型的对应](https://github.com/DiscardPast/MoocStudy/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE/TCPIP%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94.png)
	- 抽象工厂模式
	- ![TCP/IP模型与OSI模型的对应](https://github.com/DiscardPast/MoocStudy/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE/TCPIP%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94.png)
	- 单例模式
        - 应用场合
        	- 有且只有一个对象就足够了
        - 作用
        	- 保证整个应用程序中某个实例有且只有一个
        - 类型
        	- 饿汉模式
        	- 懒汉模式
        	- 两者区别
        		- 饿汉模式的特点是加载类时比较慢,但运行时获取对象的速度比较快,线程安全
        		- 懒汉模式的特点是加载类时比较快,但运行时获取对象的速度比较慢,线程不安全
	- 建造者模式
	- 原型模式
* 结构型模式
	- 适配器模式
	- 装饰器模式
	- 代理模式
	- 外观模式
	- 桥接模式
	- 组合模式
	- 享元模式
* 行为型模式
	- 策略模式
	- 模板方法模式
	- 观察者模式
	- 迭代子模式
	- 责任链模式
	- 命令模式
    - 备忘录模式
	- 状态模式
	- 访问者模式
	- 中介者模式
	- 解释器模式