package com.discardpast.chapter_two;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.service.ServiceRegistryBuilder;
import org.junit.Test;

/**
 * hibernate执行流程
 * @author discardpast
 *	1.Configuration(创建Configuration对象，读取Hibernate.cfg.xml)
 *  2.SessionFaction(创建SessionFaction,读取User.hbm.xml)
 *  3.Session(创建Session对象,获取数据库的链接对象)
 *  	同时创建一个Transaction对象
 *  	然后执行Session相关操作
 *  4.关闭Teansaction对象（teansaction.commit()），关闭Session对象(session.close())
 *  5.结束
 */

/**
 * Session简介
 * @author discardpast
 *	sission可以理解为操作数据库的对象
 *	session与connection，是多对一关系，每一个session都有一个与之对应的connection,一个connection不同时刻可以提供多个session使用
 *	把对象保存在关系数据库中需要调用session的各种方法,如:save()，update(),delete(),createQuery()等.
 *
 *	获得session对象
 *	 1.openSession
 *	 2.getCurrentSession
 *	 如果使用getCurrentSession需要在hibernate.cfg.xml文件中进行配置:
 *	 如果是本地事务(jdbc事务)
 *		<propertyname="hibernate.current_session_context_class">thread</property>
 *	 如果是全局事务(jta事务)
 *		<propertyname="hibernate.current_session_context_class">jta</property>
 */

/**
 * transaction简介(事务)
 * @author discardpast
 *	hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。
 *	所以用session保存对象时,如果不开启事务,并且不手工提交事务,对象并不会真正保存在数据库中
 *	可以在保存对象之前使用session.doWork()来变成向jdbc那样自动提交事务，从而使对象保存组数据库中(但是一般不推荐这样做)
 */
public class SessionTest {

	@Test
	public void testOpenSession()
	{
		//获得配置对象
		Configuration config = new Configuration();
		//获得服务注册对象
		ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry();
		//获得SessionFactory对象
		SessionFactory sessionFactory = config.buildSessionFactory(serviceRegistry);
		//获得Session对象
		Session session = sessionFactory.openSession();
		if(session != null)
		{
			System.out.println("session创建成功！");
		}
		else
		{
			System.out.println("session创建失败！");
		}
			
 	}
	@Test
	public void testGetCurrentSession()
	{
		
	}
}
